<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <script type="text/javascript">
    // window.location.href = "https://52yang.github.io/熊.html";
    // setTimeout(window.location.href = "https://52yang.github.io", 2000);
  </script>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/love.jpg?v=5.1.0" />






<meta name="description" content="JavaScript的数组去重是一个老生常谈的话题了。随便搜一搜就能找到非常多不同版本的解法。
在微博上看到一篇文章，也写数组去重，主要推崇的方法是将利用数组元素当作对象key来去重。
细想一下，这样一个看似简单的需求，如果要做到完备，涉及的知识和需要注意的地方很多。
定义重复（相等）要去重，首先得定义，什么叫作“重复”，即具体到代码而言，两个数据在什么情况下可以算是相等的。这并不是一个很容易的问">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈JavaScript数组去重">
<meta property="og:url" content="http://ouuo.bid/2017/03/10/谈谈JavaScript数组去重/index.html">
<meta property="og:site_name" content="Yang's Blog">
<meta property="og:description" content="JavaScript的数组去重是一个老生常谈的话题了。随便搜一搜就能找到非常多不同版本的解法。
在微博上看到一篇文章，也写数组去重，主要推崇的方法是将利用数组元素当作对象key来去重。
细想一下，这样一个看似简单的需求，如果要做到完备，涉及的知识和需要注意的地方很多。
定义重复（相等）要去重，首先得定义，什么叫作“重复”，即具体到代码而言，两个数据在什么情况下可以算是相等的。这并不是一个很容易的问">
<meta property="og:updated_time" content="2017-03-10T02:15:43.698Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谈谈JavaScript数组去重">
<meta name="twitter:description" content="JavaScript的数组去重是一个老生常谈的话题了。随便搜一搜就能找到非常多不同版本的解法。
在微博上看到一篇文章，也写数组去重，主要推崇的方法是将利用数组元素当作对象key来去重。
细想一下，这样一个看似简单的需求，如果要做到完备，涉及的知识和需要注意的地方很多。
定义重复（相等）要去重，首先得定义，什么叫作“重复”，即具体到代码而言，两个数据在什么情况下可以算是相等的。这并不是一个很容易的问">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ouuo.bid/2017/03/10/谈谈JavaScript数组去重/"/>





  <title> 谈谈JavaScript数组去重 | Yang's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不会开挖掘机的厨师不是好程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouuo.bid/2017/03/10/谈谈JavaScript数组去重/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Yang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/love.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Yang's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Yang's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                谈谈JavaScript数组去重
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T09:45:34+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>JavaScript的数组去重是一个老生常谈的话题了。随便搜一搜就能找到非常多不同版本的解法。</p>
<p>在微博上看到一篇文章，也写数组去重，主要推崇的方法是将利用数组元素当作对象<code>key</code>来去重。</p>
<p>细想一下，这样一个看似简单的需求，如果要做到完备，涉及的知识和需要注意的地方很多。</p>
<h3 id="定义重复（相等）"><a href="#定义重复（相等）" class="headerlink" title="定义重复（相等）"></a>定义重复（相等）</h3><p>要去重，首先得定义，什么叫作“重复”，即具体到代码而言，两个数据在什么情况下可以算是相等的。这并不是一个很容易的问题。</p>
<p>对于原始值而言，我们很容易想到<code>1</code>和<code>1</code>是相等的，<code>&#39;1&#39;</code>和<code>&#39;1&#39;</code>也是相等的。那么，<code>1</code>和<code>&#39;1&#39;</code>是相等的么？</p>
<p>如果这个问题还好说，只要回答“是”或者“不是”即可。那么下面这些情况就没那么容易了。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>初看<code>NaN</code>时，很容易把它当成和<code>null</code>、<code>undefined</code>一样的独立数据类型。但其实，它是数字类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// number</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>);</div></pre></td></tr></table></figure></p>
<p>根据规范，比较运算中只要有一个值为NaN，则比较结果为false，所以会有下面这些看起来略蛋疼的结论：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全都是false</span></div><div class="line"><span class="number">0</span> &lt; <span class="literal">NaN</span>;</div><div class="line"><span class="number">0</span> &gt; <span class="literal">NaN</span>;</div><div class="line"><span class="number">0</span> == <span class="literal">NaN</span>;</div><div class="line"><span class="number">0</span> === <span class="literal">NaN</span>;</div></pre></td></tr></table></figure></p>
<p>以最后一个表达式<code>0 === NaN</code>为例，在规范中有明确规定（<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison" target="_blank" rel="external">http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison</a>）：</p>
<p>&emsp;&emsp; 1.If Type(x) is Number, then<br>&emsp;&emsp;&emsp;&emsp; a. If x is NaN, return false.<br>&emsp;&emsp;&emsp;&emsp; b. If y is NaN, return false.<br>&emsp;&emsp;&emsp;&emsp; c. If x is the same Number value as y, return true.<br>&emsp;&emsp;&emsp;&emsp; d. If x is +0 and y is −0, return true.<br>&emsp;&emsp;&emsp;&emsp; e. If x is −0 and y is +0, return true.<br>&emsp;&emsp;&emsp;&emsp; f. Return false.<br>这意味着任何涉及到NaN的情况都不能简单地使用比较运算来判定是否相等。比较科学的方法只能是使用<code>isNaN()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="literal">NaN</span>;</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a) &amp;&amp; <span class="built_in">isNaN</span>(b));</div></pre></td></tr></table></figure></p>
<h3 id="原始值和包装对象"><a href="#原始值和包装对象" class="headerlink" title="原始值和包装对象"></a>原始值和包装对象</h3><p>看完<code>NaN</code>是不是头都大了。好了，我们来轻松一下，看一看原始值和包装对象这一对冤家。</p>
<p>如果你研究过<code>&#39;a&#39;.trim()</code>这样的代码的话，不知道是否产生过这样的疑问：<code>&#39;a&#39;</code>明明是一个原始值（字符串），它为什么可以直接调用<code>.trim()</code>方法呢？当然，很可能你已经知道答案：因为<code>JS</code>在执行这样的代码的时候会对原始值做一次包装，让<code>&#39;a&#39;</code>变成一个字符串对象，然后执行这个对象的方法，执行完之后再把这个包装对象脱掉。可以用下面的代码来理解：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 'a'.trim();</span></div><div class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'a'</span>);</div><div class="line">tmp.trim();</div></pre></td></tr></table></figure></p>
<p>这段代码只是辅助我们理解的。但包装对象这个概念在JS中却是真实存在的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="string">'b'</span>;</div></pre></td></tr></table></figure></p>
<p><code>a</code>即是一个包装对象，它和<code>b</code>一样，代表一个字符串。它们都可以使用字符串的各种方法（比如<code>trim()</code>），也可以参与字符串运算（<code>+</code>号连接等）。</p>
<p>但他们有一个关键的区别：类型不同！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> a; <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> b; <span class="comment">// string</span></div></pre></td></tr></table></figure></p>
<p>在做字符串比较的时候，类型的不同会导致结果有一些出乎意料：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a1 = <span class="string">'a'</span>;</div><div class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'a'</span>);</div><div class="line">a1 == a2; <span class="comment">// true</span></div><div class="line">a1 == a3; <span class="comment">// true</span></div><div class="line">a2 == a3; <span class="comment">// false</span></div><div class="line">a1 === a2; <span class="comment">// false</span></div><div class="line">a1 === a3; <span class="comment">// false</span></div><div class="line">a2 === a3; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>同样是表示字符串<code>a</code>的变量，在使用严格比较时竟然不是相等的，在直觉上这是一件比较难接受的事情，在各种开发场景下，也非常容易忽略这些细节。</p>
<h3 id="对象和对象"><a href="#对象和对象" class="headerlink" title="对象和对象"></a>对象和对象</h3><p>在涉及比较的时候，还会碰到对象。具体而言，大致可以分为三种情况：纯对象、实例对象、其它类型的对象。</p>
<h4 id="纯对象"><a href="#纯对象" class="headerlink" title="纯对象"></a>纯对象</h4><p>纯对象（<code>plain object</code>）具体指什么并不是非常明确，为减少不必要的争议，下文中使用纯对象指代由字面量生成的、成员中不含函数和日期、正则表达式等类型的对象。</p>
<p>如果直接拿两个对象进行比较，不管是<code>==</code>还是<code>===</code>，毫无疑问都是不相等的。但是在实际使用时，这样的规则是否一定满足我们的需求？举个例子，我们的应用中有两个配置项：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原来有两个属性</span></div><div class="line"><span class="comment">// var prop1 = 1;</span></div><div class="line"><span class="comment">// var prop2 = 2;</span></div><div class="line"><span class="comment">// 重构代码时两个属性被放到同一个对象中</span></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">    <span class="attr">prop1</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">prop2</span>: <span class="number">2</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>假设在某些场景下，我们需要比较两次运行的配置项是否相同。在重构前，我们分别比较两次运行的<code>prop1</code>和<code>prop2</code>即可。而在重构后，我们可能需要比较<code>config</code>对象所代表的配置项是否一致。在这样的场景下，直接用<code>==</code>或者<code>===</code>来比较对象，得到的并不是我们期望的结果。</p>
<p>在这样的场景下，我们可能需要自定义一些方法来处理对象的比较。常见的可能是通过<code>JSON.stringify()</code>对对象进行序列化之后再比较字符串，当然这个过程并非完全可靠，只是一个思路。</p>
<p>如果你觉得这个场景是无中生有的话，可以再回想一下断言库，同样是基于对象成员，判断结果是否和预期相符。</p>
<h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p>实例对象主要指通过构造函数（类）生成的对象。这样的对象和纯对象一样，直接比较都是不等的，但也会碰到需要判断是否是同一对象的情况。一般而言，因为这种对象有比较复杂的内部结构（甚至有一部分数据在原型上），无法直接从外部比较是否相等。比较靠谱的判断方法是由构造函数（类）来提供静态方法或者实例方法来判断是否相等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = Klass();</div><div class="line"><span class="keyword">var</span> b = Klass();</div><div class="line">Klass.isEqual(a, b);</div></pre></td></tr></table></figure></p>
<h4 id="其它对象"><a href="#其它对象" class="headerlink" title="其它对象"></a>其它对象</h4><p>其它对象主要指数组、日期、正则表达式等这类在Object基础上派生出来的对象。这类对象各有各的特殊性，一般需要根据场景来构造判断方法，决定两个对象是否相等。</p>
<p>比如，日期对象，可能需要通过<code>Date.prototype.getTime()</code>方法获取时间戳来判断是否表示同一时刻。正则表达式可能需要通过<code>toString()</code>方法获取到原始字面量来判断是否是相同的正则表达式。</p>
<h3 id="和"><a href="#和" class="headerlink" title="==和==="></a><code>==</code>和<code>===</code></h3><p>在一些文章中，看到某一些数组去重的方法，在判断元素是否相等时，使用的是==比较运算符。众所周知，这个运算符在比较前会先查看元素类型，当类型不一致时会做隐式类型转换。这其实是一种非常不严谨的做法。因为无法区分在做隐匿类型转换后值一样的元素，例如<code>0、&#39;&#39;、false、null、undefined</code>等。</p>
<p>同时，还有可能出现一些只能黑人问号的结果，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[] == ![]; <span class="comment">//true</span></div><div class="line"><span class="built_in">Array</span>.prototype.indexOf()</div></pre></td></tr></table></figure></p>
<p>在一些版本的去重中，用到了<code>Array.prototype.indexOf()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;</div><div class="line">        <span class="comment">// indexOf返回第一个索引值，</span></div><div class="line">        <span class="comment">// 如果当前索引不是第一个索引，说明是重复值</span></div><div class="line">        <span class="keyword">return</span> arr.indexOf(item) === index;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(ret.indexOf(item) === <span class="number">-1</span>)&#123;</div><div class="line">            ret.push(item);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>既然<code>==</code>和<code>===</code>在元素相等的比较中是有巨大差别的，那么indexOf的情况又如何呢？大部分的文章都没有提及这点，于是只好求助规范。通过规范（<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.indexof" target="_blank" rel="external">http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.indexof</a>），我们知道了<code>indexOf()</code>使用的是严格比较，也就是<code>===</code>。</p>
<p>再次强调：按照前文所述，<code>===</code>不能处理<code>NaN</code>的相等性判断。</p>
<h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h3><p><code>Array.prototype.includes()</code>是<code>ES2016</code>中新增的方法，用于判断数组中是否包含某个元素，所以上面使用<code>indexOf()</code>方法的第二个版本可以改写成如下版本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(!ret.includes(item))&#123;</div><div class="line">            ret.push(item);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么，你猜猜，<code>includes()</code>又是用什么方法来比较的呢？如果想当然的话，会觉得肯定跟<code>indexOf()</code>一样喽。但是，程序员的世界里最怕想当然。翻一翻规范，发现它其实是使用的另一种比较方法，叫作“SameValueZero”比较（<a href="https://tc39.github.io/ecma262/2016/#sec-samevaluezero" target="_blank" rel="external">https://tc39.github.io/ecma262/2016/#sec-samevaluezero</a>）。</p>
<p>&emsp;&emsp; 1.If Type(x) is different from Type(y), return false.<br>&emsp;&emsp; 2.If Type(x) is Number, then<br>&emsp;&emsp;&emsp;&emsp; a. If x is NaN and y is NaN, return true.<br>&emsp;&emsp;&emsp;&emsp; b. If x is +0 and y is -0, return true.<br>&emsp;&emsp;&emsp;&emsp; c. If x is -0 and y is +0, return true.<br>&emsp;&emsp;&emsp;&emsp; d. If x is the same Number value as y, return true.<br>&emsp;&emsp;&emsp;&emsp; e. Return false.<br>&emsp;&emsp; 3.Return SameValueNonNumber(x, y).<br>注意<code>2.a</code>，如果<code>x</code>和<code>y</code>都是<code>NaN</code>，则返回<code>true</code>！也就是<code>includes()</code>是可以正确判断是否包含了<code>NaN</code>的。我们写一段代码验证一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>];</div><div class="line">arr.indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></div><div class="line">arr.includes(<span class="literal">NaN</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>可以看到<code>indexOf()</code>和<code>includes()</code>对待<code>NaN</code>的行为是完全不一样的。</p>
<h3 id="一些方案"><a href="#一些方案" class="headerlink" title="一些方案"></a>一些方案</h3><p>从上面的一大段文字中，我们可以看到，要判断两个元素是否相等（重复）并不是一件简单的事情。在了解了这个背景后，我们来看一些前面没有涉及到的去重方案。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>双重遍历是最容易想到的去重方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> isRepeat;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        isRepeat = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span>(arr[i] === arr[j])&#123;</div><div class="line">                isRepeat = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!isRepeat)&#123;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>双重遍历还有一个优化版本，但是原理和复杂度几乎完全一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[i] === arr[j])&#123;</div><div class="line">                j = ++i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ret.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方案没什么大问题，用于去重的比较部分也是自己编写实现（<code>arr[i] === arr[j]</code>），所以相等性可以自己针对上文说到的各种情况加以特殊处理。唯一比较受诟病的是使用了双重循环，时间复杂度比较高，性能一般。</p>
<h3 id="使用对象key来去重"><a href="#使用对象key来去重" class="headerlink" title="使用对象key来去重"></a>使用对象key来去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(!tmp[arr[i]])&#123;</div><div class="line">            tmp[arr[i]] = <span class="number">1</span>;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法是利用了对象（<code>tmp</code>）的<code>key</code>不可以重复的特性来进行去重。但由于对象<code>key</code>只能为字符串，因此这种去重方法有许多局限性：</p>
<p>无法区分隐式类型转换成字符串后一样的值，比如<code>1</code>和<code>&#39;1&#39;</code><br>无法处理复杂数据类型，比如对象（因为对象作为<code>key</code>会变成<code>[object Object]</code>）<br>特殊数据，比如<code>&#39;__proto__&#39;</code>会挂掉，因为<code>tmp</code>对象的<code>__proto__</code>属性无法被重写<br>对于第一点，有人提出可以为对象的<code>key</code>增加一个类型，或者将类型放到对象的<code>value</code>中来解决：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> tmpKey;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        tmpKey = <span class="keyword">typeof</span> arr[i] + arr[i];</div><div class="line">        <span class="keyword">if</span>(!tmp[tmpKey])&#123;</div><div class="line">            tmp[tmpKey] = <span class="number">1</span>;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方案也同时解决第三个问题。</p>
<p>而第二个问题，如果像上文所说，在允许对对象进行自定义的比较规则，也可以将对象序列化之后作为<code>key</code>来使用。这里为简单起见，使用<code>JSON.stringify()</code>进行序列化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> tmp = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> tmpKey;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        tmpKey = <span class="keyword">typeof</span> arr[i] + <span class="built_in">JSON</span>.stringify(arr[i]);</div><div class="line">        <span class="keyword">if</span>(!tmp[tmpKey])&#123;</div><div class="line">            tmp[tmpKey] = <span class="number">1</span>;</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Map-Key"><a href="#Map-Key" class="headerlink" title="Map Key"></a>Map Key</h3><p>可以看到，使用对象<code>key</code>来处理数组去重的问题，其实是一件比较麻烦的事情，处理不好很容易导致结果不正确。而这些问题的根本原因就是因为<code>key</code>在使用时有限制。</p>
<p>那么，能不能有一种<code>key</code>使用没有限制的对象呢？答案是——真的有！那就是<code>ES2015</code>中的<code>Map</code>。</p>
<p>Map是一种新的数据类型，可以把它想象成<code>key</code>类型没有限制的对象。此外，它的存取使用单独的<code>get()</code>、<code>set()</code>接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">tmp.set(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">tmp.get(<span class="number">1</span>); <span class="comment">// 1</span></div><div class="line">tmp.set(<span class="string">'2'</span>, <span class="number">2</span>);</div><div class="line">tmp.get(<span class="string">'2'</span>); <span class="comment">// 2</span></div><div class="line">tmp.set(<span class="literal">true</span>, <span class="number">3</span>);</div><div class="line">tmp.get(<span class="literal">true</span>); <span class="comment">// 3</span></div><div class="line">tmp.set(<span class="literal">undefined</span>, <span class="number">4</span>);</div><div class="line">tmp.get(<span class="literal">undefined</span>); <span class="comment">// 4</span></div><div class="line">tmp.set(<span class="literal">NaN</span>, <span class="number">5</span>);</div><div class="line">tmp.get(<span class="literal">NaN</span>); <span class="comment">// 5</span></div><div class="line"><span class="keyword">var</span> arr = [], obj = &#123;&#125;;</div><div class="line">tmp.set(arr, <span class="number">6</span>);</div><div class="line">tmp.get(arr); <span class="comment">// 6</span></div><div class="line">tmp.set(obj, <span class="number">7</span>);</div><div class="line">tmp.get(obj); <span class="comment">// 7</span></div></pre></td></tr></table></figure></p>
<p>由于<code>Map</code>使用单独的接口来存取数据，所以不用担心<code>key</code>会和内置属性重名（如上文提到的<code>__proto__</code>）。使用<code>Map</code>改写一下我们的去重方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = [];</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(!tmp.get(arr[i]))&#123;</div><div class="line">            tmp.set(arr[i], <span class="number">1</span>);</div><div class="line">            ret.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>既然都用到了<code>ES2015</code>，数组这件事情不能再简单一点么？当然可以。</p>
<p>除了<code>Map</code>以外，<code>ES2015</code>还引入了一种叫作Set的数据类型。顾名思义，Set就是集合的意思，它不允许重复元素出现，这一点和数学中对集合的定义还是比较像的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">s.add(<span class="number">1</span>);</div><div class="line">s.add(<span class="string">'1'</span>);</div><div class="line">s.add(<span class="literal">null</span>);</div><div class="line">s.add(<span class="literal">undefined</span>);</div><div class="line">s.add(<span class="literal">NaN</span>);</div><div class="line">s.add(<span class="literal">true</span>);</div><div class="line">s.add([]);</div><div class="line">s.add(&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>如果你重复添加同一个元素的话，<code>Set</code>中只会存在一个。包括<code>NaN</code>也是这样。于是我们想到，这么好的特性，要是能和数组互相转换，不就可以去重了吗？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(set);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们讨论了这么久的事情，居然两行代码搞定了，简直不可思议。</p>
<p>然而，不要只顾着高兴了。有一句话是这么说的“不要因为走得太远而忘了为什么出发”。我们为什么要为数组去重呢？因为我们想得到不重复的元素列表。而既然已经有<code>Set</code>了，我们为什么还要舍近求远，使用数组呢？是不是在需要去重的情况下，直接使用<code>Set</code>就解决问题了？这个问题值得思考。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/wechatpay.jpg" alt="Yang WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/alipay.jpg" alt="Yang Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/07/JavaScript中reduce方法/" rel="next" title="JavaScript中reduce方法">
                <i class="fa fa-chevron-left"></i> JavaScript中reduce方法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/love.jpg"
               alt="Yang" />
          <p class="site-author-name" itemprop="name">Yang</p>
           
              <p class="site-description motion-element" itemprop="description">晚上少吃点？</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义重复（相等）"><span class="nav-number">1.</span> <span class="nav-text">定义重复（相等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NaN"><span class="nav-number">2.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原始值和包装对象"><span class="nav-number">3.</span> <span class="nav-text">原始值和包装对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象和对象"><span class="nav-number">4.</span> <span class="nav-text">对象和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#纯对象"><span class="nav-number">4.1.</span> <span class="nav-text">纯对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例对象"><span class="nav-number">4.2.</span> <span class="nav-text">实例对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它对象"><span class="nav-number">4.3.</span> <span class="nav-text">其它对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和"><span class="nav-number">5.</span> <span class="nav-text">==和===</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-prototype-includes"><span class="nav-number">6.</span> <span class="nav-text">Array.prototype.includes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些方案"><span class="nav-number">7.</span> <span class="nav-text">一些方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历"><span class="nav-number">8.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用对象key来去重"><span class="nav-number">9.</span> <span class="nav-text">使用对象key来去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-Key"><span class="nav-number">10.</span> <span class="nav-text">Map Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">11.</span> <span class="nav-text">Set</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yang</span>
</div>



<!--
<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>
-->


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
